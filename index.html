<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>PetitComputer4 Fullscreen Port</title>
    <style>
        /* 余白を消してキャンバスを画面いっぱいに */
        body, html { margin: 0; padding: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #status {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-family: monospace;
            pointer-events: none; /* クリックを邪魔しない */
            text-shadow: 1px 1px 2px #000;
        }
    </style>
</head>
<body>
    <div id="status"></div>
    <canvas id="gameCanvas"></canvas>

<script>
/**
 * ブラウザサイズ適応版
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const statusDiv = document.getElementById('status');

// 定数（変数値として扱う）
const FOOD_NUM = 150; // 画面が広いので少し増やしました
const FOOD_KIND = 18;
const KCAL_PER_FOOD = 200;

let screenW, screenH;
let player, foods, eatedCount, totalKcal, isMoving, gameOver;

// 画面サイズに合わせて初期化
function init() {
    screenW = window.innerWidth;
    screenH = window.innerHeight;
    canvas.width = screenW;
    canvas.height = screenH;

    eatedCount = 0;
    totalKcal = 0;
    isMoving = false;
    gameOver = false;

    // プレイヤーを画面中央に配置
    player = { x: screenW / 2, y: screenH / 2, area: 0, target: null };

    // エサを画面全体に配置
    foods = [];
    for (let i = 0; i < FOOD_NUM; i++) {
        foods.push({
            x: 15 + Math.random() * (screenW - 30),
            y: 15 + Math.random() * (screenH - 30),
            color: `hsl(${(i % FOOD_KIND) * (360/FOOD_KIND)}, 70%, 60%)`,
            active: true
        });
    }
}

// リサイズ対応
window.addEventListener('resize', () => {
    // 実行中にリサイズされると配置がズレるため、再初期化するのが安全です
    init();
});

function update() {
    if (gameOver) return;

    if (!isMoving) {
        let foundIndex = -1;
        for (let i = 0; i < foods.length; i++) {
            let f = foods[i];
            if (!f.active) continue;

            let dist = Math.hypot(f.x - player.x, f.y - player.y);
            if (dist < (12 + player.area)) {
                foundIndex = i;
                break;
            }
        }

        if (foundIndex !== -1) {
            player.target = foods[foundIndex];
            isMoving = true;
        } else {
            // 索敵スピード（高速）
            player.area += 6.0; 
        }
    } else {
        // 移動処理 (10倍速)
        let dx = player.target.x - player.x;
        let dy = player.target.y - player.y;
        let dist = Math.hypot(dx, dy);
        let speed = 40; 

        if (dist <= speed) {
            player.x = player.target.x;
            player.y = player.target.y;
            player.target.active = false;
            eatedCount++;
            totalKcal += KCAL_PER_FOOD;
            player.area = 0;
            isMoving = false;

            if (eatedCount >= FOOD_NUM) gameOver = true;
        } else {
            player.x += (dx / dist) * speed;
            player.y += (dy / dist) * speed;
        }
    }
    
    // UI更新
    statusDiv.innerHTML = `EATED: ${eatedCount} / ${FOOD_NUM} | TOTAL: ${totalKcal} kcal`;
}

function draw() {
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, screenW, screenH);

    // エサ
    foods.forEach(f => {
        if (!f.active) return;
        ctx.fillStyle = f.color;
        ctx.beginPath();
        ctx.arc(f.x, f.y, 5, 0, Math.PI * 2);
        ctx.fill();
    });

    // 索敵範囲
    ctx.strokeStyle = "rgba(255, 255, 255, 0.15)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.area + 10, 0, Math.PI * 2);
    ctx.stroke();

    // プレイヤー
    ctx.fillStyle = gameOver ? "#ff0" : "#0af";
    ctx.beginPath();
    ctx.arc(player.x, player.y, 10, 0, Math.PI * 2);
    ctx.fill();

    if (gameOver) {
        ctx.fillStyle = "#fff";
        ctx.font = "bold 40px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("ごちそうサマンサ", screenW / 2, screenH / 2);
    }
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

init();
loop();
</script>
</body>
</html>
